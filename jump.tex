\hypertarget{fpn:jump1}{}\label{fpn:jump}

\pagestyle{fpn}

\rput(7.9,-0.5){\resizebox{!}{14cm}{{\epsfbox{images/articulos/jump_header.eps}}}}

\psset{fillstyle=solid}
\psframe[fillcolor=black,opacity=0.7](2,-4.5)(17,0)



% -------------------------------------------------
% Cabecera
\begin{flushright}


{\color{introcolor}\mtitle{14cm}{Saltar en Medio de una Función}}

\msubtitle{8cm}{Una nueva técnica de obfuscación de código}

{\sf\color{white}{ por Carolyn Lightrun}}

%{{\psset{linecolor=black,linestyle=dotted}\psline(-12,0)}}
\end{flushright}


\vspace{2mm}
% -------------------------------------------------


%\lstset{language=C,frame=tb,framesep=5pt,basicstyle=\footnotesize}
\lstset{language=C,frame=tb,framesep=5pt,basicstyle=\scriptsize}



\intro{introcolor}{E}{l otro día me pregunté\ldots{} ¿Cómo podría hacer que un programa
saltara en medio de una función?. Lo creáis o no, había una razón para
pensar eso, pero en el momento de escribir este artículo no la
recuerdo\ldots{} Sin embargo, esa pregunta aparentemente estúpida, me ha
llevado a un viaje muy interesante que me gustaría compartir con
vosotros.}


\begin{multicols}{2}


La verdad que a parte de una forma de ofuscar el código y confundir a
los desesambladores/descompiladores, no se me ocurre ninguna otra razón
por la que intentar saltar en medio de una función, pero bueno, quizás
la haya y acabe recordándolo o alguno de vosotros me deis alguna idea.

La idea es algo como esto:

\begin{lstlisting}[language=C]
int foo () {
    puts ("Entramos en Función foo");
en_medio:
    puts ("Código en medio de la función");
    puts ("Salimos de Función foo");
}
int main () {
   goto en_medio;
}
\end{lstlisting}

El código de arriba no funciona pero su objetivo es solo ilustrar el
concepto del que vamos a hablar en este artículo. La razón de que no
funcione es que las etiquetas (\emph{labels}) solo están definidas
dentro de la función en la que se usan y no pueden ser usadas desde
fuera de ellas y, por lo tanto, {\verb!goto!} no tiene
ni idea de que estamos hablando cuando le decimos que salte a
{\verb!en_medio!}.

\hypertarget{setjmplongjmp}{%
\sectiontext{white}{black}{setjmp/longjmp}\label{setjmplongjmp}}

La primera solución que se nos vendría a la cabeza sería utilizar las
funciones {\verb!setjmp!} y
{\verb!longjmp!}. Estas funciones para mi despiertan un
sentimiento de estar usando magia arcana y la verdad que solo las he
visto utilizar por código bastante viejo del de los origines de UNIX y
el dialecto K\&R de C. Si os preguntáis por su utilidad en el mundo
real\ldots{} bueno, nos permiten implementar en C un comportamiento
similar al de las excepciones de otros lenguajes.

Este es un ejemplo clásico de su uso:

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <setjmp.h>

jmp_buf b1;

int foo () {
  puts (" > foo inicio\n");
  longjmp (b1, 1);
}

int main () {
  puts ("> main ()\n");
  if (setjmp (b1) != 0) {
    puts ("Llamada especial\n");
  } else
    foo ();
  puts ("> main fin\n");
}
\end{lstlisting}

La función {\verb!setjmp!} marca un punto de retorno y
para ello almacena el estado actual del programa (el valor de los
registros del procesador y alguna cosa más) en una estructura global de
tipo {\verb!jmp\_buf!}. La función comprueba el valor
de retorno. Si es cero, significa que es la primera ejecución de la
función y dicho de forma sencilla, estaremos grabando el estado actual
del programa al que volveremos en caso de que pase algo.

Si {\verb!setjmp!} retorna un valor distinto de cero,
significa que hemos vuelto a este punto del programa debido a una
llamada a la función {\verb!longjmp!} y por tanto
debemos restaurar el estado y que todo siga como la primera vez que
llamamos a {\verb!setjmp!}.

En nuestro código de ejemplo. La primera llamada a
{\verb!setjmp!} devolverá cero tras inicializa el
estado actual y, acto seguido, ejecutará la función
{\verb!foo!}.

La función {\verb!foo!} hace sus cosas, y en un momento
determinado, algo pasa y ejecuta {\verb!longjmp!}
pasándole como parámetro el estado al que queremos retornar y el valor
que va a recibir {\verb!setjmp!}. Si, podemos enviar
distintos valores con distintas llamadas a
{\verb!longjmp!}. En nuestro código, el efecto de este
{\verb!longjmp!} es la impresión del mensaje
{\verb!Llamada Especial!}.

{\verb!longjmp!} fuerza el retorno a la llamada
{\verb!setjmp!} anterior restaurando el estado, pero
devolviendo el valor 1, lo que hace que la condición se cumpla y
entremos en la parte {\verb!then!} del bloque
{\verb!if!}.

Parece que esto funciona super bien, así que vamos a utilizarlo para
nuestro caso.

\begin{quote}
Como podéis ver, estas dos funciones también nos permiten hacer un bucle
infinito de una forma bastante peculiar\ldots{} Si lo implementáis
\emph{Mostradnos el código!}
\end{quote}

\hypertarget{saltando-con-longjmp}{%
\sectiontext{white}{black}{SALTANDO CON LONGJMP}\label{saltando-con-longjmp}}

Con todo lo que sabemos de {\verb!setjmp!} y
{\verb!longjmp!} podríamos re-escribir nuestro programa
para saltar en medio de una función de la siguiente forma:

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <setjmp.h>

jmp_buf b1;

int foo () {
  puts (" > foo inicio\n");
  if (setjmp (b1) != 0) {
    puts ("Llamada especial\n");
  } else
    puts (" > foo final\n");
}

int main () {
  foo (); // poin setjmp
  longjmp (b1, 1);
}
\end{lstlisting}

En este caso, tenemos que hacer una llama extra a
{\verb!foo!} para poder ejecutar
{\verb!setjmp!} y almacenar el estado que nos permita
volver al punto en el que ejecutar nuestro código especial. En otras
palabras, {\verb!setjmp!} va a definir el punto en
medio de la función al que queremos saltar.

Bueno, si compiláis y ejecutáis este programa obtendréis un fallo de
segmentación. Lo que sucede es que estas funciones restauran los
registros y alguna información adicional, pero no pueden almacenar el
estado de la pila. Cuando las usamos como en el caso anterior en el que
{\verb!setjmp!} esta en el mismo marco de pila o
superior a {\verb!longjmp!} todo va bien, puesto que
{\verb!longjmp!} limpiará la pila de forma automática
al restaurar el segmento de pila. Pero si lo hacemos al revés,
{\verb!longjmp!} va a restaurar la pila a un posición
que era válida dentro de la función, pero que ya no lo es y además ha
podido ser modificada por otro código que se haya ejecutado entre
medias.

\hypertarget{abusando-de-goto}{%
\sectiontext{white}{black}{ABUSANDO DE GOTO}\label{abusando-de-goto}}

Ya que la forma estándar de saltar entre funciones no ha funcionado como
esperamos, vamos a utilizar la forma más básica de saltar a una
determinada posición de memoria\ldots{}
{\verb!goto!}\ldots{} la instrucción maldita.

Una forma de implementar esto sería con el siguiente código:

\begin{lstlisting}[language=C]
#include <stdio.h>

void *f1 = NULL;

int foo (int a) {
  f1 = &&label_foo1;
  puts ("> foo inicio");
  
  if (a) {
  label_foo1:
    puts ("Llamada especial");
    return 0;
  }
  printf ("> foo final\n");
  return 0;
}

int main () {
  puts ("> main ()");
  foo (0);
  goto *f1;
  puts ("> main fin");
}
\end{lstlisting}

Si bien, el programa es corto y tiene pocos elementos, hay muchas cosas
que explicar. Lo primero es la declaración de un puntero como una
variable global (la primera línea después de los includes). Este puntero
tiene que ser global puesto que la forma más directa de obtener un
puntero a una parte específica de una función es utilizando etiquetas, y
solo podemos acceder a las etiquetas de una función desde esa misma
función. Para poder acceder desde fuera tenemos que almacenar ese
puntero en un lugar que podamos leer desde otras funciones, como por
ejemplo\ldots{} Una variable global.

La siguiente línea que puede que os llame la atención es

\begin{lstlisting}
f1 = &&label_foo1;
\end{lstlisting}

El operador {\verb!&&!} es específico de gcc y nos
permite obtener la dirección de memoria asociada a una etiqueta. Dicho
esto la línea ya no tiene misterios. Estamos almacenando en el puntero
{\verb!f1!} la dirección de memoria a la que queremos
saltar.

Finalmente, la función {\verb!main!}, incluye una
primera llamada a {\verb!foo!} con un parámetro para
inicializar el puntero global. Una vez inicializa podemos saltar usando
{\verb!goto!} simplemente dereferenciando el puntero.

Veamos si esta solución funciona:¨

\begin{lstlisting}
$ make jump-ex01
cc     jump-ex01.c   -o jump-ex01
$ ./jump-ex01
> main ()
> foo inicio
> foo final
Llamada especial
\end{lstlisting}

Pero parece que tenemos un problemilla con esta implementación. ¿Podéis
verlo?\ldots{}

\hypertarget{los-problemas-con-goto}{%
\sectiontext{white}{black}{LOS PROBLEMAS CON GOTO}\label{los-problemas-con-goto}}

El primer problema es que tras ejecutar el código de la \emph{``Llamada
Especial''}, en lugar de retornar a {\verb!main!}
nuestro programa termina. Os imaginaréis que es lo que pasa. Cuando
retornamos de {\verb!foo!} al haber saltado en medio de
la función, seguimos en el \emph{stack frame} de
{\verb!main!}, con lo que al restaurar el puntero de
pila y retornar, estamos efectivamente haciendo un
{\verb!return!} desde {\verb!main!}.

Esto lo podemos solucionar fácilmente, forzando que la función retorne
después de la llamada especial pero sin restaurar el
\emph{stack\_frame}, algo como esto:

\begin{lstlisting}[language=C]
  if (a) {
  label_foo1:
    puts ("Llamada especial");
    __asm__ ("ret");
  }
\end{lstlisting}

Solo con esta modificación el programa producirá una violación de
segmento, ya que la dirección de retorno no está en la pila y la
instrucción {\verb!ret!} que hemos introducido va a
saltar a una dirección aleatoria. Para solucionar esto, debemos
asegurarnos que el primer valor en la pila sea la dirección de retorno
correcta.

Podríamos hacer todo esto insertando ensamblador, pero la verdad que
usar ensamblador en GCC de esta forma es muy engorroso, y cuanto más
ensamblador introduzcamos menos portable será nuestro programa. Así que
lo que vamos a hacer es decirle al compilador que en lugar de saltar
(usar la instrucción {\verb!goto!} que se convierte en
un {\verb!jmp!} en ensamblador), ejecute una función
({\verb!call!}), la cual ya va a introducir en la pila
la dirección correcta para retornar.

Esto lo podemos hacer sustituyendo nuestro
{\verb!goto *f1!} por con una línea tan críptica como
esta:

\begin{lstlisting}[language=C]
((int (*)())f1)();
\end{lstlisting}

La línea anterior simplemente hace un cast de nuestra dirección de
memoria en medio de {\verb!foo!} a una función, y luego
le dice al compilador que invoque la función (los
{\verb!()!} del final). Esto hará que el compilador
introduzca una instrucción {\verb!call!} que es lo que
necesitamos.

El otro problema de usar {\verb!goto!} es que la forma
en la que lo hemos usado es una extensión de GCC y no sigue el estándar,
el cual indica que solo podemos usar como parámetro a
{\verb!goto!} etiquetas locales. Sin embargo, con la
última modificación que hemos hecho, ya hemos solucionado ese problema
al dejar de utilizar {\verb!goto!}.

\hypertarget{mejorando-nuestro-ejemplo}{%
\sectiontext{white}{black}{MEJORANDO NUESTRO EJEMPLO}\label{mejorando-nuestro-ejemplo}}

Vamos a extender nuestro programa de ejemplo, añadiendo dos puntos de
entrada a la función {\verb!foo!} y utilizando punteros
a funciones directamente, de forma que no es necesario utilizar esos
casts tan extraños como el que vimos en la sección anterior.

El programa sería algo como esto:

\begin{lstlisting}[language=C]
#include <stdio.h>

int (*f1)() = NULL;
int (*f2)() = NULL;


int foo (int a) {
  f1 = &&label_foo1;
  f2 = &&label_foo2;
  puts ("> foo inicio");
  
  if (a) {
  label_foo1:
    puts ("Llamada especial 1");
    __asm__ ("ret");
    
  label_foo2:
    puts ("Llamada especial 2");
    __asm__ ("ret");

  }
 label_end:
  puts ("> foo final");
  return 0;
}

int main () {
  puts ("> main ()");
  foo (0);
  f1();
  f2();
  puts ("> main fin");
}
\end{lstlisting}

Sin sorpresas verdad?. Simplemente hemos declarado nuestras variables
globales {\verb!f1!} y {\verb!f2!}
como punteros a funciones, y así la llamada en
{\verb!main!} a ambas etiquetas es tan sencilla como
llamar a un función.

El programa funciona correctamente y ahora, lo que vamos a hacer, es
intentar que las llamadas especiales no se puedan ver claramente cuando
el programa es desensamblado. Como referencia, esto es lo que vemos con
el programa tal cual con {\verb!objdump!} y con {\verb!radare2!}:

\end{multicols}




\begin{minipage}{0.48\linewidth}
\includegraphics[width=\linewidth]{images/articulos/jump-ex03-radare2.eps}
\captionof{figure}{Salida de radare2}
\end{minipage}
\begin{minipage}{0.48\linewidth}
\includegraphics[width=\linewidth]{images/articulos/jump-ex03-objdump.eps}
\captionof{figure}{Salida de objdump}
\end{minipage}






\begin{multicols}{2}

Claramente podemos ver las llamadas especiales en ambos casos y radare
incluso nos muestra las cadenas. En el resto del artículo solo
mostraremos la salida de radare2 que es mucho más completa.

El objetivo ahora es confundir a radare2 para que no nos muestre
inmediatamente las funciones especiales que hemos escondido en
{\verb!foo!}.

\hypertarget{ocultando-el-cuxf3digo-i}{%
\sectiontext{white}{black}{OCULTANDO EL CÓDIGO I}\label{ocultando-el-cuxf3digo-i}}

Lo primero que vamos a hacer es insertar algunos caracteres aleatorios
justo antes de nuestra primera etiqueta, con el objetivo de confundir al
desensamblador al encontrar código que no se corresponden con
instrucciones. Esto lo podemos hacer de la siguiente forma:

\begin{entradilla}
{\em Incluyendo algunos valores aleatorios antes de una función podemos confundir a los desensambladores}
\end{entradilla}

\begin{lstlisting}[language=C]
  if (a) {
    __asm__ (".asciz \"ROOR\"");
  label_foo1:
    puts ("Llamada especial 1");
    __asm__ ("ret");
\end{lstlisting}

Si ahora vemos la salida de radare2 obtendremos lo siguiente:

\includegraphics[width=\linewidth]{images/articulos/jump-ex04-radare2.eps}


Como podemos ver ahora radare no es capaz de encontrar la cadena de la
primera llamada especial. Aún podemos ver algo de código de la función,
pero ya no es tan evidente como antes. Podemos repetir el proceso antes
de la segunda etiqueta para intentar ocultar también la segunda cadena:


\includegraphics[width=\linewidth]{images/articulos/jump-ex05-radare2.eps}


Pero si usamos las capacidades de análisis de radare, ejecutando el
comando

\begin{lstlisting}
[0x00001050]> aaaaaa
INFO: Analyze all flags starting with sym. and entry0 (aa)
INFO: Analyze imports (af@@@i)
INFO: Analyze entrypoint (af@ entry0)
INFO: Analyze symbols (af@@@s)
INFO: Recovering variables
INFO: Analyze all functions arguments/locals (afva@@@F)
INFO: Analyze function calls (aac)
INFO: Analyze len bytes of instructions for references (aar)
INFO: Finding and parsing C++ vtables (avrr)
INFO: Analyzing methods
INFO: Recovering local variables (afva)
INFO: Type matching analysis for all functions (aaft)
INFO: Propagate noreturn information (aanr)
INFO: Scanning for strings constructed in code (/azs)
INFO: Finding function preludes (aap)
INFO: Enable anal.types.constraint for experimental
type propagation
INFO: Reanalizing graph references to adjust functions
count (aarr)
INFO: Autoname all functions (.afna@@c:afla)
\end{lstlisting}

\end{multicols}

\rput(8.2,2.8){\resizebox{!}{5.8cm}{{\epsfbox{images/promo/promo04.eps}}}}

\pagebreak
\begin{multicols}{2}

Ahora veremos lo siguiente:

\includegraphics[width=\linewidth]{images/articulos/jump-ex06-radare2.eps}

La segunda cadena ha vuelto a aparecer. Maldita sea, radare es más listo
de lo que pensábamos. Veamos en detalle el comentario junto a la nueva
línea que ha descubierto.

\begin{lstlisting}
|   0x0000118e  ~   00488d
                         add byte [rax - 0x73], cl
|   ; DATA XREF from sub.foo_1139 @ 0x1152(r)
+ 16: sub.Llamada_especial_2_118f ();
|   0x0000118f      488d058e0e..
                        lea rax, str.Llamada_especial_2
                        ; 0x2024 ; "Llamada especial 2"
\end{lstlisting}

Al parecer ha encontrado una referencia cruzada en la dirección
{\verb!0x1152!} y gracias a ello ha sido capaz de
averiguar que hay algo en esa dirección. La dirección en cuestión
contiene:

\begin{lstlisting}
0x0001152      488d053600..
               lea rax, [sub.Llamada_especial_2_118f]
               ; 0x118f ; "H\x8d\x05\x8e\x0e"
\end{lstlisting}

Es decir, es la línea en la que asignamos a la variable global
{\verb!f2!} la dirección de la etiqueta
{\verb!label\_foo2!}\ldots{}

\hypertarget{escondiendo-el-cuxf3digo-muxe1s}{%
\sectiontext{white}{black}{ESCONDIENDO EL CÓDIGO
MÁS}\label{escondiendo-el-cuxf3digo-muxe1s}}

Bueno, vamos a ponérselo un poco más difícil a radare. En lugar de
almacenar las direcciones directamente en las variables globales,
hagamos algunas operaciones con ellas:

\begin{lstlisting}[language=C]
int foo (int a) {
  f1 = &&label_foo1 - 0x1234;
  f2 = &&label_foo2 + 0x4321;
  puts ("> foo inicio");
  f1 += 0x1234;
  f2 -= 0x4321;
  (...)
\end{lstlisting}

Y esto es lo que obtenemos:

\includegraphics[width=\linewidth]{images/articulos/jump-ex07-radare2.eps}


Genial, ya no hay referencia cruzada que valga. Sin embargo, aún podemos
ver todo el código si bien no es evidente cuales son los puntos de
acceso, ya que las direcciones se calculan en tiempo de ejecución. Un
sencillo análisis dinámico las mostrará, pero eso significa que ya hemos
forzado al investigador al siguiente nivel, el cual implica una cierta
preparación.

\begin{entradilla}
{\em Calcular las direcciones de las funciones usando una operación, dificulta la labor del desensamblador}
\end{entradilla}

A partir de este punto podéis aplicar distintas técnicas de ofuscación
para hacer más complicado averiguar que es lo que hace el programa. Por
mi parte voy a insertar una serie de saltos al final de la función justo
antes del código de las funciones especiales, para que parezca que el
código real nunca se ejecuta\ldots{} si bien esto es algo muy sencillo
de ver cuando se hace un análisis dinámico.

Los cambios al código son los siguientes:

\begin{lstlisting}[language=C]
 if (a) {
    __asm__ ("jmp . + 123");
    __asm__ (".asciz \"PRUEBA\"");
  label_foo1:
    puts ("Llamada especial 1");
    __asm__ ("ret");
    __asm__ ("jmp . + 123");
    __asm__ (".asciz \"PRUEBA\"");
  label_foo2:
    puts ("Llamada especial 2");
    __asm__ ("ret");
  }
\end{lstlisting}

Como podéis ver, hemos cambiado {\verb!ROOR!} por
{\verb!PRUEBA!} que genera más opcodes inválidos.Ahora
solo tenemos que calcular los offsets de los
{\verb!jmps!} del código de arriba y sustituir los
valores.

Para ello vamos a volcar la función {\verb!foo!} con
{\verb!objdump!} tras compilar esta última versión:

\end{multicols}

\begin{lstlisting}
occams@razor > objdump -d jump-ex08 | grep "<foo>:" -A 50
0000000000001139 <foo>:
    1139:   55                      push   %rbp
    113a:   48 89 e5                mov    %rsp,%rbp
    113d:   48 83 ec 10             sub    $0x10,%rsp
    1141:   89 7d fc                mov    %edi,-0x4(%rbp)
    1144:   48 8d 05 27 ee ff ff    lea    -0x11d9(%rip),%rax        # ffffffffffffff72 <_end+0xffffffffffffbf42>
    114b:   48 89 05 ce 2e 00 00    mov    %rax,0x2ece(%rip)        # 4020 <f1>
    1152:   48 8d 05 87 43 00 00    lea    0x4387(%rip),%rax        # 54e0 <_end+0x14b0>
    1159:   48 89 05 c8 2e 00 00    mov    %rax,0x2ec8(%rip)        # 4028 <f2>
    1160:   48 8d 05 9d 0e 00 00    lea    0xe9d(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1167:   48 89 c7                mov    %rax,%rdi
    116a:   e8 c1 fe ff ff          call   1030 <puts@plt>
    116f:   48 8b 05 aa 2e 00 00    mov    0x2eaa(%rip),%rax        # 4020 <f1>
    1176:   48 05 34 12 00 00       add    $0x1234,%rax
    117c:   48 89 05 9d 2e 00 00    mov    %rax,0x2e9d(%rip)        # 4020 <f1>
    1183:   48 8b 05 9e 2e 00 00    mov    0x2e9e(%rip),%rax        # 4028 <f2>
    118a:   48 2d 21 43 00 00       sub    $0x4321,%rax
    1190:   48 89 05 91 2e 00 00    mov    %rax,0x2e91(%rip)        # 4028 <f2>
    1197:   83 7d fc 00             cmpl   $0x0,-0x4(%rbp)
    119b:   74 34                   je     11d1 <foo+0x98>
    119d:   eb 79                   jmp    1218 <main+0x30>
    119f:   50                      push   %rax
    11a0:   52                      push   %rdx
    11a1:   55                      push   %rbp
    11a2:   45                      rex.RB
    11a3:   42                      rex.X
    11a4:   41 00 48 8d             add    %cl,-0x73(%r8)
    11a8:   05 64 0e 00 00          add    $0xe64,%eax
    11ad:   48 89 c7                mov    %rax,%rdi
    11b0:   e8 7b fe ff ff          call   1030 <puts@plt>
    11b5:   c3                      ret
    11b6:   eb 79                   jmp    1231 <main+0x49>
    11b8:   50                      push   %rax
    11b9:   52                      push   %rdx
    11ba:   55                      push   %rbp
    11bb:   45                      rex.RB
    11bc:   42                      rex.X
    11bd:   41 00 48 8d             add    %cl,-0x73(%r8)
    11c1:   05 5e 0e 00 00          add    $0xe5e,%eax
    11c6:   48 89 c7                mov    %rax,%rdi
    11c9:   e8 62 fe ff ff          call   1030 <puts@plt>
    11ce:   c3                      ret
    11cf:   eb 01                   jmp    11d2 <foo+0x99>
    11d1:   90                      nop
    11d2:   48 8d 05 5e 0e 00 00    lea    0xe5e(%rip),%rax        # 2037 <_IO_stdin_used+0x37>
    11d9:   48 89 c7                mov    %rax,%rdi
    11dc:   e8 4f fe ff ff          call   1030 <puts@plt>
    11e1:   b8 00 00 00 00          mov    $0x0,%eax
    11e6:   c9                      leave
    11e7:   c3                      ret
\end{lstlisting}

\begin{multicols}{2}

Si miramos con atención, el primer salto está en
{\verb!0x119b!} y el siguiente salto está en
{\verb!0x11b6!}. Queremos que parezcan puntos de
salida, así que haremos que salten a {\verb!0x11e7!}.
Lo que significa que debemos usar los offsets:

\begin{entradilla}
{\em Si en lugar de instrucciones aleatorias inyectamos instrucciones con un propósito, podemos hacer que parezca que el programa hace algo distinto }
\end{entradilla}

\begin{lstlisting}
$ echo $((0x11e7-0x119d))
74
$ echo $((0x11e7-0x11b6))
49
\end{lstlisting}

Si actualizamos el código y recompilamos, esto es lo que mostrará ahora
radare.

\includegraphics[width=\linewidth]{images/articulos/jump-ex08-radare2.eps}


\hypertarget{otros-puntos-de-vista}{%
\sectiontext{white}{black}{OTROS PUNTOS DE VISTA}\label{otros-puntos-de-vista}}

En todo el artículo hemos estado mirando al código usando el comando
{\verb!pd!} de radare2. Este comando hace el
desensamblado de la zona de memoria que le indicamos, sin embargo,
radare2 ofrece formas más convenientes de ver al código que son las que
la mayoría de la gente usa. Una de ellas es utilizando el comando
{\verb!pdf!} el cual nos ofrece el desensamblado de una
zona de memoria, pero suponiendo que se trata de una función. Esto es lo
que obtendríamos:

\includegraphics[width=\linewidth]{images/articulos/jump-ex08-radare2-func.eps}


Como podéis ver, todo el código especial que hemos incluido no se
muestra, sin embargo, si prestamos atención, veréis dos puntos que
rompen las líneas de los saltos, indicándonos que ahí hay algo que no se
está mostrando\ldots{}

\begin{entradilla}
{\em Al utilizar comandos más avanzados como \texttt{pdf} es más difícil ver que algo está mal} 
\end{entradilla}

La otra forma que la gente usa para ver al código es el modo gráfico,
popularizado por la herramienta IDA Pro y que nos permite, de un
vistazo, ver la estructura general del programa de forma gráfica.
radare2 ofrece esta vista en modo texto, pero podéis usar alguno de los
GUIs para interactuar con el para verlo en modo gráfico. Para nuestro
ejemplo, esta vista mostraría lo siguiente:


\includegraphics[width=\linewidth]{images/articulos/jump-ex08-radare2-graph.eps}

Para mostrar el gráfico de la figura, una vez cargado el programa,
ejecutad el análisis completo con el comando
{\verb!aaaaaa!} y luiego entrad en modo gráfico con el
comando {\verb!VV!}. Una ver en modo gráfico, para
mostrar la función {\verb!foo!} , pulsad
{\verb!g!} e introducid el nombre que radare2 le ha
dado ({\verb!sym.foo!}).

En esta vista, no es obvio ver que hay una parte del código que no se
está mostrando. Podéis utilizar el comando {\verb!p!}
para cambiar la representación y añadir las direcciones\ldots{} sin
embargo, a no ser que soñéis en hexadecimal y prestéis bastante
atención, es bastante probable que no os percatéis que falta un cacho de
código.

Así que recordad que si las cosas no cuadran igual hay que mirar más en
detalle ;).
\EOP
\end{multicols}

\rput(8.0,-4.5){\resizebox{!}{9.2cm}{{\epsfbox{images/promo/promo01.eps}}}}
